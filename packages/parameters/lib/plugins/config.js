// Generated by CoffeeScript 2.5.1
  // ## Plugin "config"

// Dependencies
var Shell, builder_main, builder_options, clone, is_object_literal, merge, mutate, types, utils,
  indexOf = [].indexOf;

utils = require('../utils');

({clone, is_object_literal, merge, mutate} = require('mixme'));

// Shell.js & plugins
Shell = require('../Shell');

builder_main = function(commands) {
  var builder, ctx;
  ctx = this;
  builder = {
    get: function() {
      var config;
      config = ctx.confx(commands).raw();
      return clone(config.main);
    },
    set: function(value) {
      var config;
      config = ctx.confx(commands).raw();
      if (value === void 0) {
        // Do nothing if value is undefined
        return builder;
      }
      // Unset the property if null
      if (value === null) {
        config.main = void 0;
        return builder;
      }
      if (typeof value === 'string') {
        value = {
          name: value
        };
      }
      config.main = value;
      return builder;
    }
  };
  return builder;
};

builder_options = function(commands) {
  var builder, ctx;
  ctx = this;
  builder = function(name) {
    return {
      get: function(properties) {
        var copy, j, len, option, options, property;
        // Initialize options with cascaded options
        options = builder.show();
        option = options[name];
        if (typeof properties === 'string') {
          properties = [properties];
        }
        if (!Array.isArray(properties)) {
          return option;
        }
        copy = {};
        for (j = 0, len = properties.length; j < len; j++) {
          property = properties[j];
          copy[property] = option[property];
        }
        return copy;
      },
      remove: function(name) {
        var config;
        config = ctx.confx(commands).raw();
        return delete config.options[name];
      },
      set: function() {
        var collide, config, option, ref, values;
        config = ctx.confx(commands).raw();
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw utils.error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        if (config.options && !is_object_literal(config.options)) {
          throw utils.error(['Invalid Options:', `expect an object, got ${JSON.stringify(config.options)}`]);
        }
        option = config.options[name] = merge(config.options[name], values);
        if (!ctx.config.extended) {
          if (!option.disabled && commands.length) {
            // Compare the current command with the options previously registered
            collide = ctx.collision[name] && ctx.collision[name].filter(function(cmd, i) {
              return commands[i] !== cmd;
            }).length === 0;
            if (collide) {
              throw utils.error(['Invalid Option Configuration:', `option ${JSON.stringify(name)}`, `in command ${JSON.stringify(commands.join(' '))}`, `collide with the one in ${ctx.collision[name].length === 0 ? 'application' : JSON.stringify(ctx.collision[name].join(' '))},`, "change its name or use the extended property"]);
            }
          }
          // Associate options with their declared command
          ctx.collision[name] = commands;
        }
        // Normalize option
        option.name = name;
        if (option.type == null) {
          option.type = 'string';
        }
        if (ref = option.type, indexOf.call(types, ref) < 0) {
          throw utils.error(['Invalid Option Configuration:', `supported options types are ${JSON.stringify(types)},`, `got ${JSON.stringify(option.type)}`, `for option ${JSON.stringify(name)}`, commands.length ? `in command ${JSON.stringify(commands.join(' '))}` : void 0]);
        }
        if (typeof option.enum === 'string') {
          // config.shortcuts[option.shortcut] = option.name if option.shortcut and not option.disabled
          option.enum = [option.enum];
        }
        if (option.enum && !Array.isArray(option.enum)) {
          throw utils.error(['Invalid Option Configuration:', 'option property "enum" must be a string or an array,', `got ${option.enum}`]);
        }
        return this;
      }
    };
  };
  builder.__proto__ = {
    get_cascaded: function() {
      var cascade_is_number, command, config, i, j, len, name, option, options, ref;
      options = {};
      config = ctx.confx().raw();
      for (i = j = 0, len = commands.length; j < len; i = ++j) {
        command = commands[i];
        ref = config.options;
        for (name in ref) {
          option = ref[name];
          if (!option.cascade) {
            continue;
          }
          cascade_is_number = typeof option.cascade === 'number';
          if (cascade_is_number && commands.length > option.cascade + i) {
            continue;
          }
          options[name] = clone(option);
        }
        config = config.commands[command];
      }
      return options;
    },
    show: function() {
      var config, name, option, options;
      // Initialize options with cascaded options
      options = builder.get_cascaded();
      for (name in options) {
        option = options[name];
        option.transient = true;
      }
      // Get app/command configuration
      config = ctx.confx(commands).raw();
      // Merge cascaded with local options
      options = merge(options, config.options);
      for (name in options) {
        option = options[name];
        if (option.disabled) {
          delete options[name];
        }
      }
      return options;
    },
    list: function() {
      return Object.keys(builder.show()).sort();
    }
  };
  return builder;
};

Shell.prototype.confx = function(command = []) {
  var base, ctx, j, lconfig, len, name;
  ctx = this;
  if (typeof command === 'string') {
    command = [command];
  }
  // command = [...pcommand, ...command]
  lconfig = this.config;
  for (j = 0, len = command.length; j < len; j++) {
    name = command[j];
    // A new command doesn't have a config registered yet
    if ((base = lconfig.commands)[name] == null) {
      base[name] = {};
    }
    lconfig = lconfig.commands[name];
  }
  return {
    main: builder_main.call(this, command),
    options: builder_options.call(this, command),
    get: function() {
      var _, base1, config, l, len1, option, ref, ref1, source, strict;
      source = ctx.config;
      strict = source.strict;
      for (l = 0, len1 = command.length; l < len1; l++) {
        name = command[l];
        if (!source.commands[name]) {
          // TODO: create a more explicit message,
          // including somehting like "command #{name} is not registered",
          // also ensure it is tested
          throw utils.error(['Invalid Command']);
        }
        // A new command doesn't have a config registered yet
        if ((base1 = source.commands)[name] == null) {
          base1[name] = {};
        }
        source = source.commands[name];
        if (source.strict) {
          strict = source.strict;
        }
      }
      config = clone(source);
      config.strict = strict;
      if (command.length) {
        config.command = command;
      }
      ref = config.commands;
      for (name in ref) {
        _ = ref[name];
        config.commands[name] = ctx.confx([...command, name]).get();
      }
      config.options = this.options.show();
      config.shortcuts = {};
      ref1 = config.options;
      for (name in ref1) {
        option = ref1[name];
        if (option.shortcut) {
          config.shortcuts[option.shortcut] = option.name;
        }
      }
      if (config.main != null) {
        config.main = this.main.get();
      }
      return config;
    },
    set: function() {
      var l, len1, values;
      values = null;
      if (arguments.length === 2) {
        values = {
          [arguments[0]]: arguments[1]
        };
      } else if (arguments.length === 1) {
        values = arguments[0];
      } else {
        throw utils.error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
      }
      lconfig = ctx.config;
      for (l = 0, len1 = command.length; l < len1; l++) {
        name = command[l];
        // A new command doesn't have a config registered yet
        // lconfig.commands[name] ?= {}
        lconfig = lconfig.commands[name];
      }
      mutate(lconfig, values);
      ctx.hook('configure_set', {
        config: lconfig,
        command: command,
        values: values
      }, ({config, command, values}) => {
        var k, ref, ref1, v;
        // config.name = name
        if (!command.length) {
          if (config.extended == null) {
            config.extended = false;
          }
          if (typeof config.extended !== 'boolean') {
            throw utils.error(['Invalid Configuration:', 'extended must be a boolean,', `got ${JSON.stringify(config.extended)}`]);
          }
          config.root = true;
          if (config.name == null) {
            config.name = 'myapp';
          }
          if (Object.keys(config.commands).length) {
            if (config.command == null) {
              config.command = 'command';
            }
          }
          if (config.strict == null) {
            config.strict = false;
          }
        } else {
          if (config.name && config.name !== command.slice(-1)[0]) {
            throw utils.error(['Incoherent Command Name:', `key ${JSON.stringify(name)} is not equal with name ${JSON.stringify(config.name)}`]);
          }
          if (config.command != null) {
            throw utils.error(['Invalid Command Configuration:', 'command property can only be declared at the application level,', `got command ${JSON.stringify(config.command)}`]);
          }
          if (config.extended != null) {
            throw utils.error(['Invalid Command Configuration:', 'extended property cannot be declared inside a command']);
          }
          config.name = command.slice(-1)[0];
        }
        if (config.commands == null) {
          config.commands = {};
        }
        if (config.options == null) {
          config.options = {};
        }
        if (config.shortcuts == null) {
          config.shortcuts = {};
        }
        ref = config.options;
        for (k in ref) {
          v = ref[k];
          this.options(k).set(v);
        }
        ref1 = config.commands;
        for (k in ref1) {
          v = ref1[k];
          ctx.confx([...command, k]).set(v);
        }
        return this.main.set(config.main);
      });
      return this;
    },
    // remove: ->
    //   delete lconfig.options[command]
    raw: function() {
      return lconfig;
    }
  };
};

// ## Internal types
types = ['string', 'boolean', 'integer', 'array'];
