// Generated by CoffeeScript 2.5.1
// ## Plugin "grpc"

// Dependencies
var Shell, Transform, get_handlers, grpc, mutate, passthrough, path, proto, utils;

path = require('path');

utils = require('shell/lib/utils');

({mutate} = require('mixme'));

try {
  grpc = require('grpc');
} catch (error) {
  grpc = require('@grpc/grpc-js');
}

proto = require('@shell-js/grpc_proto');

// Shell & plugins
Shell = require('shell/lib/Shell');

require('shell/lib/plugins/config');

require('shell/lib/plugins/router');

({Transform} = require('stream'));

Shell.prototype.init = (function(parent) {
  return function() {
    // Plugin configuration
    this.register({
      configure_set: function({config, command}, handler) {
        var base, base1, base2;
        if (command.length) {
          return handler;
        }
        if (config.grpc == null) {
          config.grpc = {};
        }
        if ((base = config.grpc).address == null) {
          base.address = '127.0.0.1';
        }
        if ((base1 = config.grpc).port == null) {
          base1.port = 61234;
        }
        if ((base2 = config.grpc).command_protobuf == null) {
          base2.command_protobuf = false;
        }
        return handler;
      }
    });
    // Register the "shell protobuf" command
    this.register({
      configure_set: function({config, command}, handler) {
        if (command.length) {
          return handler;
        }
        if (!config.grpc.command_protobuf) {
          return handler;
        }
        mutate(config, {
          commands: {
            'shell': {
              commands: {
                'protobuf': {
                  options: {
                    format: {
                      enum: ['json', 'proto'],
                      default: 'proto'
                    }
                  },
                  handler: path.resolve(__dirname, './route_shell_protobuf')
                }
              }
            }
          }
        });
        return handler;
      }
    });
    return parent.call(this, ...arguments);
  };
})(Shell.prototype.init);

passthrough = function() {
  return new Transform({
    objectMode: true,
    transform: function(chunk, encoding, callback) {
      chunk = {
        data: chunk
      };
      return callback(null, chunk);
    }
  });
};

get_handlers = function(definition) {
  return {
    ping: function(call, callback) {
      return callback(null, {
        message: call.request.name
      });
    },
    config: function(call, callback) {
      var config;
      config = this.confx(call.request.command).get();
      return callback(null, {
        config: config
      });
    },
    run: function(call) {
      var context;
      context = {
        argv: call.request.argv,
        is_grpc: true
      };
      if (call.readable) {
        context.reader = call;
      }
      if (call.writable) {
        context.stdout = passthrough();
        context.stdout.pipe(call);
        context.stderr = passthrough();
        context.stderr.pipe(call);
      }
      return this.route(context);
    }
  };
};

Shell.prototype.grpc_start = function(callback) {
  var appconfig, endpoint, handler, handlers, name, packageDefinition, promise, ref, server, shell_definition;
  if ((ref = this._server) != null ? ref.started : void 0) {
    throw utils.error('GRPC Server Already Started');
  }
  appconfig = this.confx().get();
  // Load the definition
  packageDefinition = proto.loadSync();
  shell_definition = grpc.loadPackageDefinition(packageDefinition).shell;
  // Instantiate the server
  server = new grpc.Server();
  handlers = get_handlers(shell_definition);
  for (name in handlers) {
    handler = handlers[name];
    handlers[name] = handler.bind(this);
  }
  server.addService(shell_definition.Shell.service, handlers);
  endpoint = `${appconfig.grpc.address}:${appconfig.grpc.port}`;
  promise = new Promise(function(resolve, reject) {
    return server.bindAsync(endpoint, grpc.ServerCredentials.createInsecure(), function(err, port) {
      server.start();
      if (err) {
        return reject(err);
      } else {
        return resolve(port);
      }
    });
  });
  this._server = server;
  return promise;
};

Shell.prototype.grpc_stop = function() {
  // server = @_server
  return new Promise((resolve, reject) => {
    if (!this.grpc_started()) {
      return resolve(false);
    }
    return this._server.tryShutdown((err) => {
      // Note, as of june 2019,
      // grpc marks the server as started but not as stopped
      this._server.started = false;
      if (err) {
        return reject(err);
      } else {
        return resolve(true);
      }
    });
  });
};

Shell.prototype.grpc_started = function() {
  var ref;
  return !!((ref = this._server) != null ? ref.started : void 0);
};
