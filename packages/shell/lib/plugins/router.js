// Generated by CoffeeScript 2.5.1
// ## Plugin "router"

// Dependencies
var Shell, clone, is_object_literal, merge, path, stream, utils;

path = require('path');

stream = require('stream');

utils = require('../utils');

({clone, merge, is_object_literal} = require('mixme'));

// Shell.js & plugins
Shell = require('../Shell');

require('../plugins/config');

Shell.prototype.init = (function(parent) {
  return function() {
    this.register({
      configure_set: function({config, command}, handler) {
        var base, base1, base2, base3, base4, base5;
        if (command.length) {
          return handler;
        }
        if (config.router == null) {
          config.router = {};
        }
        if ((base = config.router).handler == null) {
          base.handler = path.resolve(__dirname, '../routes/help');
        }
        if ((base1 = config.router).stdin == null) {
          base1.stdin = process.stdin;
        }
        if ((base2 = config.router).stdout == null) {
          base2.stdout = process.stdout;
        }
        if ((base3 = config.router).stdout_end == null) {
          base3.stdout_end = false;
        }
        if ((base4 = config.router).stderr == null) {
          base4.stderr = process.stderr;
        }
        if ((base5 = config.router).stderr_end == null) {
          base5.stderr_end = false;
        }
        if (!(config.router.stdin instanceof stream.Readable)) {
          throw utils.error(["Invalid Configuration Property:", "router.stdin must be an instance of stream.Readable,", `got ${JSON.stringify(config.router.stdin)}`]);
        }
        if (!(config.router.stdout instanceof stream.Writable)) {
          throw utils.error(["Invalid Configuration Property:", "router.stdout must be an instance of stream.Writable,", `got ${JSON.stringify(config.router.stdout)}`]);
        }
        if (!(config.router.stderr instanceof stream.Writable)) {
          throw utils.error(["Invalid Configuration Property:", "router.stderr must be an instance of stream.Writable,", `got ${JSON.stringify(config.router.stderr)}`]);
        }
        return handler;
      }
    });
    return parent.call(this, ...arguments);
  };
})(Shell.prototype.init);

Shell.prototype.init = (function(parent) {
  return function() {
    this.register({
      configure_set: function({config, command}, handler) {
        var ref;
        if (!config.handler) {
          return handler;
        }
        if ((ref = typeof config.handler) !== 'function' && ref !== 'string') {
          throw utils.error(['Invalid Route Configuration:', "accept string or function", !command.length ? "in application," : void 0, command.length ? `in command ${JSON.stringify(command.join(' '))},` : void 0, `got ${JSON.stringify(config.handler)}`]);
        }
        return handler;
      }
    });
    return parent.call(this, ...arguments);
  };
})(Shell.prototype.init);


// ## Method `route(context, ...users_arguments)`

// * `cli_arguments`: `[string] | object | process` The arguments to parse into arguments, accept the [Node.js process](https://nodejs.org/api/process.html) instance, an [argument list](https://nodejs.org/api/process.html#process_process_argv) provided as an array of strings or the context object; optional, default to `process`.
// * `...users_arguments`: `any` Any arguments that will be passed to the executed function associated with a route.
// * Returns: `any` Whatever the route function returns.

// How to use the `route` method to execute code associated with a particular command.
Shell.prototype.route = function(context = {}, ...args) {
  var appconfig, command, config, err, handler, i, params, route_call, route_error, route_from_config, route_load;
  // Normalize arguments
  if (Array.isArray(context)) {
    context = {
      argv: context
    };
  } else if (!is_object_literal(context)) {
    throw utils.error(['Invalid Router Arguments:', 'first argument must be a context object or the argv array,', `got ${JSON.stringify(context)}`]);
  }
  appconfig = this.confx().get();
  route_load = (handler) => {
    if (typeof handler === 'string') {
      return this.load(handler);
    } else if (typeof handler === 'function') {
      return handler;
    } else {
      throw utils.error(`Invalid Handler: expect a string or a function, got ${handler}`);
    }
  };
  route_call = (handler, command, params, err, args) => {
    var config;
    config = this.confx().get();
    context = {
      argv: process.argv.slice(2),
      command: command,
      error: err,
      params: params,
      args: args,
      stdin: config.router.stdin,
      stdout: config.router.stdout,
      stdout_end: config.router.stdout_end,
      stderr: config.router.stderr,
      stderr_end: config.router.stderr_end,
      ...context
    };
    return this.hook('router_call', context, (context) => {
      return handler.call(this, context, ...args);
    });
  };
  route_error = (err, command) => {
    var handler, params;
    context.argv = command.length ? ['help', ...command] : ['--help'];
    params = this.parse(context.argv);
    handler = route_load(this.config.router.handler);
    return route_call(handler, command, params, err, args);
  };
  route_from_config = (config, command, params) => {
    var err, handler;
    handler = config.handler;
    if (!handler) {
      // Provide an error message if leaf command without a handler
      if (!Object.keys(config.commands).length) { // Object.keys(config.commands).length or
        err = config.root ? utils.error(['Missing Application Handler:', 'a \"handler\" definition is required when no child command is defined']) : utils.error(['Missing Command Handler:', `a \"handler\" definition ${JSON.stringify(params[appconfig.command])} is required when no child command is defined`]);
      }
      // Convert argument to an help command
      context.argv = command.length ? ['help', ...command] : ['--help'];
      params = this.parse(context.argv);
      handler = route_load(this.config.router.handler);
    } else {
      handler = route_load(handler);
    }
    return route_call(handler, command, params, err, args);
  };
  try {
    // Read arguments
    params = this.parse(context.argv);
  } catch (error) {
    err = error;
    return route_error(err, err.command || []);
  }
  // Print help
  if (command = this.helping(params)) {
    // this seems wrong, must be the handler of the command
    handler = this.load(appconfig.router.handler);
    return route_call(handler, command, params, err, args);
  } else {
    // Return undefined if not parsing command based arguments
    // Load a command route
    command = params[appconfig.command];
    if (appconfig.extended) {
      // TODO: not tested yet, construct a commands array like in flatten mode when extended is activated
      command = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = params.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(params[i][appconfig.command]);
        }
        return results;
      })();
    }
    config = this.confx(command).get();
    return route_from_config(config, command || [], params);
  }
};
